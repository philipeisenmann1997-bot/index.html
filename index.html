<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Push-to-Talk</title>
  <style>
    :root { --bg:#0b0f14; --muted:#8aa0b2; --accent:#34c759; --danger:#ff453a; }
    * { box-sizing:border-box }
    html, body { height:100%; }
    body {
      margin:0; background:#0b0f14; color:#dbe7f3;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .wrap {
      min-height:100dvh; display:flex; align-items:center; justify-content:center; padding:20px;
    }
    .card {
      width:min(880px,94vw); background:#111922; border-radius:18px;
      box-shadow:0 12px 36px rgba(0,0,0,.45); padding:22px; position:relative; z-index:0;
    }
    h1 { margin:0 0 10px; font-weight:800; letter-spacing:.2px }
    .row { display:flex; gap:12px; align-items:center; margin:6px 0 12px; flex-wrap:wrap }
    .small { font-size:.9rem; color:#9bb0c3 }
    #ptt {
      display:block; width:100%;
      padding:18px 22px; border-radius:16px; border:1px solid #1d2a37;
      background:var(--accent); color:#051015; font-size:1.15rem; font-weight:800;
      user-select:none; -webkit-user-select:none; cursor:pointer;
      position:relative; z-index:5;
    }
    #ptt[disabled] { filter:grayscale(.6); opacity:.65; cursor:not-allowed }
    .bubble { background:#0f1720; border:1px solid #1d2a37; border-radius:14px; padding:12px 14px; margin-top:10px }
    .log { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.86rem; color:#a9bcd0; white-space:pre-wrap }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Push-to-Talk</h1>
      <div class="row">
        <span class="small" id="styleLbl">Stil: tief, ruhig</span>
        <span class="small" id="recLbl">bereit – tippen &amp; halten zum Sprechen</span>
      </div>

      <button id="ptt" type="button">Zum Sprechen tippen &amp; halten</button>

      <div class="bubble">
        <div class="small"><b>Gesagt:</b> <span id="said">–</span></div>
        <div class="small"><b>Antwort:</b> <span id="answer">–</span></div>
      </div>

      <div class="bubble">
        <div class="log" id="log">Bereit.</div>
      </div>

      <!-- Optional: serverseitige TTS-URL abspielen -->
      <audio id="player" playsinline preload="none"></audio>
    </div>
  </div>

<script>
/** === Konfiguration ===================================================== */
const WEBHOOK = "https://n8n.srv1112525.hstgr.cloud/webhook/adbfc875-ecdc-433b-85f9-aba25b8beaa5"; // ← deine n8n-URL

/** === DOM-Refs ========================================================== */
const el = {
  ptt: document.getElementById('ptt'),
  recLbl: document.getElementById('recLbl'),
  said: document.getElementById('said'),
  answer: document.getElementById('answer'),
  log: document.getElementById('log'),
  audio: document.getElementById('player'),
};

/** === Utilities ========================================================= */
let isRecording = false;
let pressed = false;
let primed = false;

function log(t){ el.log.textContent = t; }
function setRecLabel(t){ el.recLbl.textContent = t; }

/** iOS/Browser Audio „aufwecken“ (erfordert User-Geste) */
async function primeAudio() {
  try {
    if (window.AudioContext || window.webkitAudioContext) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      if (ctx.state === 'suspended') await ctx.resume();
      const buf = ctx.createBuffer(1, 1, 22050);
      const src = ctx.createBufferSource(); src.buffer = buf;
      src.connect(ctx.destination); src.start(0);
      setTimeout(()=>ctx.close(), 120);
    }
    if (window.speechSynthesis?.paused) window.speechSynthesis.resume();
  } catch(e){}
}

/** === Speech-to-Text (Web Speech API) ================================ */
const SpeechRecognition =
  window.SpeechRecognition || window.webkitSpeechRecognition;

if (!SpeechRecognition) {
  log("Dieses Gerät/Browser unterstützt keine Sprach­erkennung.");
}

const recognition = SpeechRecognition ? new SpeechRecognition() : null;
if (recognition) {
  recognition.lang = "de-DE";
  recognition.interimResults = false; // nur finale Ergebnisse
  recognition.continuous = false;     // Push-to-Talk Verhalten
}

/** Aufnahme (eigentlich Erkennung) starten/stoppen */
async function startRecord(){
  if (isRecording || !recognition) return;
  isRecording = true;
  el.ptt.setAttribute('aria-pressed', 'true');

  try {
    await primeAudio();
    log("Höre zu …");
    setRecLabel("Erkennung läuft … gedrückt halten");
    recognition.start();
  } catch (err) {
    isRecording = false;
    el.ptt.setAttribute('aria-pressed', 'false');
    log("Start fehlgeschlagen: " + err.name + " – " + err.message);
    setRecLabel("Fehler – erneut versuchen");
  }
}

async function stopRecord(){
  if (!isRecording || !recognition) return;
  isRecording = false;
  el.ptt.setAttribute('aria-pressed', 'false');
  try {
    recognition.stop();
    setRecLabel("verarbeite …");
  } catch(e) {
    setRecLabel("bereit – tippen & halten zum Sprechen");
  }
}

/** Ergebnis → nur TEXT an n8n senden */
if (recognition) {
  recognition.onresult = async (ev) => {
    const text = (ev.results?.[0]?.[0]?.transcript || "").trim();
    if (!text) {
      log("Nichts erkannt.");
      setRecLabel("bereit – tippen & halten zum Sprechen");
      return;
    }

    el.said.textContent = text;
    log("Sende Text an n8n …");

    try {
      const res = await fetch(WEBHOOK, {
        method:'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify({
          source: 'voice',
          text: text
        })
      });

      const data = await res.json().catch(()=> ({}));
      // Erwartete Felder: output | text | ttsUrl
      const reply = (data.output || data.text || "").toString();

      el.answer.textContent = reply || "–";
      setRecLabel("bereit – tippen & halten zum Sprechen");
      log(`Antwort erhalten (${res.status})`);

      if (data.ttsUrl) {
        el.audio.src = data.ttsUrl;
        try { await el.audio.play(); } catch(e){}
      } else if (reply) {
        speak(reply);
      }
    } catch (err) {
      log("Fehler beim Senden: " + err.message);
      setRecLabel("Fehler – erneut versuchen");
    }
  };

  recognition.onerror = (ev) => {
    // typische Fehler: not-allowed, no-speech, network, aborted
    if (ev.error === "not-allowed" || ev.error === "service-not-allowed") {
      log("Mikro blockiert. Öffne die Seite in Safari/Chrome (nicht aus einer App) und erlaube Mikrofon unter iOS-Einstellungen.");
      setRecLabel("Mikrofon-Zugriff nötig");
    } else if (ev.error === "no-speech") {
      log("Kein Sprachsignal erkannt.");
      setRecLabel("bereit – tippen & halten zum Sprechen");
    } else {
      log("Erkennungsfehler: " + ev.error);
      setRecLabel("Fehler – erneut versuchen");
    }
    isRecording = false;
    el.ptt.setAttribute('aria-pressed', 'false');
  };

  recognition.onend = () => {
    // Wird nach stop() und teilweise nach Fehlern aufgerufen
    // Status-Label setzen wir an den relevanten Stellen.
  };
}

/** === TTS (Browser), iOS-freundlich ================================== */
function speak(txt){
  try { window.speechSynthesis.cancel(); } catch(e){}

  const u = new SpeechSynthesisUtterance();
  // Bud-Style
  u.rate = 0.82;   // langsamer
  u.pitch = 0.6;   // tiefer
  u.volume = 1.0;

  const pickVoice = () => {
    const list = window.speechSynthesis.getVoices();
    return list.find(v => /de|german|deu/i.test(v.lang)) || list[0];
  };

  const trySpeak = () => {
    const v = pickVoice();
    if (!v) return false;
    u.voice = v;
    // Satzzeichen entfernen, damit nichts „vorgelesen“ wird
    u.text = (txt||"").replace(/[^\w äöüÄÖÜß]/g, ' ').replace(/\s+/g, ' ').trim();
    window.speechSynthesis.speak(u);
    return true;
  };

  if (!trySpeak()) {
    window.speechSynthesis.onvoiceschanged = () => trySpeak();
  }
}

/** === Pointer Events: robust für Touch + Maus ========================= */
el.ptt.addEventListener('pointerdown', async (ev) => {
  pressed = true;
  el.ptt.setPointerCapture?.(ev.pointerId);
  if (!primed) { await primeAudio(); primed = true; }
  await startRecord();
}, {passive:true});

const end = async () => {
  if (!pressed) return;
  pressed = false;
  await stopRecord();
};
['pointerup','pointercancel','pointerleave'].forEach(t => {
  el.ptt.addEventListener(t, end, {passive:true});
});

/** Sicherheitsnetz: bei jeder Geste Audio/Sprachsystem reaktivieren */
['pointerdown','click','touchstart','touchend'].forEach(type=>{
  document.addEventListener(type, ()=> {
    if (!primed) { primeAudio(); primed = true; }
    try { if (speechSynthesis.paused) speechSynthesis.resume(); } catch(e){}
  }, {passive:true});
});
</script>
</body>
</html>

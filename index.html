<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Push-to-Talk</title>
  <style>
    :root { --bg:#0b0f14; --muted:#8aa0b2; --accent:#34c759; --danger:#ff453a; }
    *{box-sizing:border-box} body{margin:0;background:#0b0f14;color:#dbe7f3;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .wrap{min-height:100svh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:min(860px,94vw);background:#111922;border-radius:18px;box-shadow:0 8px 34px rgba(0,0,0,.45);padding:22px}
    h1{margin:0 0 12px;font-weight:700}
    .row{display:flex;gap:12px;align-items:center;margin:6px 0 12px}
    .btn{width:100%;padding:18px 22px;border-radius:14px;border:1px solid #1d2a37;background:var(--accent);color:#031015;font-size:1.1rem;font-weight:700;user-select:none}
    .btn[disabled]{filter:grayscale(.6);cursor:not-allowed;opacity:.7}
    .status{font-size:.95rem;color:#a4b6c6}
    .bubble{background:#0f1720;border:1px solid #1d2a37;border-radius:14px;padding:12px 14px;margin-top:10px}
    .small{font-size:.86rem;color:#7d90a3}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Push-to-Talk</h1>
    <div class="row">
      <span class="small" id="voiceLbl">Stil: tief, ruhig</span>
      <span class="small" id="recLbl">bereit – tippen & halten zum Sprechen</span>
    </div>

    <button id="ptt" class="btn">Zum Sprechen tippen &amp; halten</button>

    <div class="bubble">
      <div class="small"><b>Gesagt:</b> <span id="said">–</span></div>
      <div class="small"><b>Antwort:</b> <span id="answer">–</span></div>
    </div>

    <div class="bubble" style="margin-top:12px">
      <div class="small status" id="log">Bereit.</div>
    </div>

    <!-- Für serverseitiges TTS (optional) -->
    <audio id="player" playsinline preload="none"></audio>
  </div>
</div>

<script>
const WEBHOOK = "https://n8n.srv1112525.hstgr.cloud/webhook/adbfc875-ecdc-433b-85f9-aba25b8beaa5"; // <<< DEINE URL

const el = {
  ptt: document.getElementById('ptt'),
  recLbl: document.getElementById('recLbl'),
  said: document.getElementById('said'),
  answer: document.getElementById('answer'),
  log: document.getElementById('log'),
  audio: document.getElementById('player'),
};

let media, recorder, chunks = [];
let speaking = false;

function log(m){ el.log.textContent = m; }
function setRecLabel(t){ el.recLbl.textContent = t; }

// ------- Aufnahme (iOS-freundlich) -------
async function startRecord(){
  if (!navigator.mediaDevices?.getUserMedia) {
    log("Kein Mikrofonzugriff im Browser verfügbar.");
    return;
  }
  try{
    media = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mime = MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4'
               : MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus'
               : 'audio/webm';
    recorder = new MediaRecorder(media, { mimeType: mime });
    chunks = [];
    recorder.ondataavailable = e => e.data.size && chunks.push(e.data);
    recorder.onstop = onStop;
    recorder.start();
    setRecLabel("Erkennung läuft … halte gedrückt");
  }catch(err){
    log("Mikrofon abgelehnt oder nicht verfügbar: " + err.message);
  }
}

async function stopRecord(){
  try{ recorder?.state !== 'inactive' && recorder?.stop(); }catch(e){}
  try{ media?.getTracks().forEach(t => t.stop()); }catch(e){}
  setRecLabel("Sende Audio …");
}

async function onStop(){
  const blob = new Blob(chunks, { type: recorder.mimeType || 'audio/mp4' });
  chunks = [];
  // für iOS: mp4 Endung
  const fname = (recorder.mimeType || '').includes('mp4') ? 'speech.m4a' : 'speech.webm';

  const fd = new FormData();
  fd.append('audio', blob, fname);         // <-- n8n Webhook: binary „audio“
  fd.append('reply_mode', 'http');         // optional: Meta
  try {
    const res = await fetch(WEBHOOK, { method:'POST', body: fd });
    if(!res.ok) throw new Error(await res.text());
    const data = await res.json().catch(()=> ({}));

    // Erwartet: { output: "Text …", ttsUrl?: "https://…/audio.mp3" }
    const text = data.output || data.text || "";
    el.said.textContent = text ? el.said.textContent : "–";
    el.answer.textContent = text || "–";
    log("Antwort erhalten.");

    // TTS abspielen – zuerst serverseitige URL, sonst Browser-TTS
    if (data.ttsUrl) {
      el.audio.src = data.ttsUrl;     // muss CORS + https liefern
      try { await el.audio.play(); speaking = true; } catch(e){ /* iOS block? */ }
    } else if (text) {
      speak(text);
    }
    setRecLabel("bereit – tippen & halten zum Sprechen");
  } catch(err){
    log("Fehler beim Senden: " + err.message);
    setRecLabel("Fehler – erneut versuchen");
  }
}

// ------- iOS-sicheres TTS (Browser) -------
function speak(txt){
  // iOS braucht sauberes Cancel / Resume und muss nach User-Interaktion laufen
  try { window.speechSynthesis.cancel(); } catch(e){}
  const u = new SpeechSynthesisUtterance();

  // Stimme grob „Bud-Style“
  u.rate = 0.82;     // langsamer
  u.pitch = 0.6;     // tiefer
  u.volume = 1.0;

  // best effort Voice-Pick
  const pick = () => {
    const list = speechSynthesis.getVoices();
    return list.find(v => /german|de-|deu/i.test(v.lang)) || list[0];
  };
  const trySpeak = () => {
    const v = pick();
    if (v) {
      u.voice = v;
      u.text = (txt || "").replace(/[!?.,;:]/g, " ").replace(/\s+/g, " ").trim(); // Satzzeichen vermeiden
      speechSynthesis.speak(u);
      speaking = true;
      return true;
    }
    return false;
  };
  if (!trySpeak()) {
    window.speechSynthesis.onvoiceschanged = () => trySpeak();
  }
}

// Workaround: iOS pausiert Speech manchmal – bei Touch wieder anstoßen
['touchstart','touchend'].forEach(ev => {
  document.addEventListener(ev, () => {
    try { if (speechSynthesis.paused) speechSynthesis.resume(); } catch(e){}
  }, {passive:true});
});

// ------- UI: gedrückt halten -------
let pressing = false;
el.ptt.addEventListener('touchstart', ev => { pressing=true; ev.preventDefault(); startRecord(); }, {passive:false});
el.ptt.addEventListener('mousedown',   ev => { pressing=true; startRecord(); });

const stop = ev => {
  if(!pressing) return;
  pressing=false;
  stopRecord();
};
['touchend','touchcancel','mouseup','mouseleave'].forEach(ev => el.ptt.addEventListener(ev, stop));
</script>
</body>
</html>

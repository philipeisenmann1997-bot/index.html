<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Push-to-Talk</title>
  <style>
    :root { --bg:#0b0f14; --muted:#8aa0b2; --accent:#34c759; --danger:#ff453a; }
    * { box-sizing:border-box }
    html, body { height:100%; }
    body {
      margin:0; background:#0b0f14; color:#dbe7f3;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .wrap {
      min-height:100dvh; display:flex; align-items:center; justify-content:center; padding:20px;
    }
    .card {
      width:min(880px,94vw); background:#111922; border-radius:18px;
      box-shadow:0 12px 36px rgba(0,0,0,.45); padding:22px; position:relative; z-index:0;
    }
    h1 { margin:0 0 10px; font-weight:800; letter-spacing:.2px }
    .row { display:flex; gap:12px; align-items:center; margin:6px 0 12px; flex-wrap:wrap }
    .small { font-size:.9rem; color:#9bb0c3 }
    #ptt {
      display:block; width:100%;
      padding:18px 22px; border-radius:16px; border:1px solid #1d2a37;
      background:var(--accent); color:#051015; font-size:1.15rem; font-weight:800;
      user-select:none; -webkit-user-select:none; cursor:pointer;
      position:relative; z-index:5;
    }
    #ptt[disabled] { filter:grayscale(.6); opacity:.65; cursor:not-allowed }
    .bubble { background:#0f1720; border:1px solid #1d2a37; border-radius:14px; padding:12px 14px; margin-top:10px }
    .log { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.86rem; color:#a9bcd0; white-space:pre-wrap }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Push-to-Talk</h1>
      <div class="row">
        <span class="small" id="styleLbl">Stil: tief, ruhig</span>
        <span class="small" id="recLbl">bereit – tippen & halten zum Sprechen</span>
      </div>

      <button id="ptt" type="button">Zum Sprechen tippen &amp; halten</button>

      <div class="bubble">
        <div class="small"><b>Gesagt:</b> <span id="said">–</span></div>
        <div class="small"><b>Antwort:</b> <span id="answer">–</span></div>
      </div>

      <div class="bubble">
        <div class="log" id="log">Bereit.</div>
      </div>

      <!-- Optional: serverseitige TTS-URL abspielen -->
      <audio id="player" playsinline preload="none"></audio>
    </div>
  </div>

<script>
const WEBHOOK = "https://n8n.srv1112525.hstgr.cloud/webhook/adbfc875-ecdc-433b-85f9-aba25b8beaa5"; // <— deine URL

const el = {
  ptt: document.getElementById('ptt'),
  recLbl: document.getElementById('recLbl'),
  said: document.getElementById('said'),
  answer: document.getElementById('answer'),
  log: document.getElementById('log'),
  audio: document.getElementById('player'),
};

let media = null, recorder = null, chunks = [];
let isRecording = false;
let spokenOnce = false; // für iOS: AudioContext/Synthesis anstupsen

function log(t){ el.log.textContent = t; }
function setRecLabel(t){ el.recLbl.textContent = t; }

// ---------- iOS Audio/Speech „Aufwecken“ ----------
async function primeAudio() {
  try {
    // Safari braucht einen gestenbasierten „Kick“
    if (window.AudioContext || window.webkitAudioContext) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      if (ctx.state === 'suspended') await ctx.resume();
      // 1-sample Silence
      const buf = ctx.createBuffer(1, 1, 22050);
      const src = ctx.createBufferSource(); src.buffer = buf;
      src.connect(ctx.destination); src.start(0);
      setTimeout(()=>ctx.close(), 120);
    }
    if (window.speechSynthesis?.paused) window.speechSynthesis.resume();
  } catch(e){}
}

// ---------- Aufnahme starten ----------
async function startRecord(){
  if (isRecording) return;
  isRecording = true;
  el.ptt.setAttribute('aria-pressed', 'true');

  try {
    await primeAudio();
    const constraints = {
      audio: {
        channelCount: 1,
        noiseSuppression: true,
        echoCancellation: true,
        sampleRate: 48000
      }
    };
    log("Frage Mikrofon an …");
    media = await navigator.mediaDevices.getUserMedia(constraints);
    const mime = [
      'audio/mp4', 'audio/webm;codecs=opus', 'audio/webm'
    ].find(t => MediaRecorder.isTypeSupported(t)) || 'audio/webm';

    recorder = new MediaRecorder(media, { mimeType: mime });
    chunks = [];
    recorder.ondataavailable = e => e.data.size && chunks.push(e.data);
    recorder.onstop = onStop;

    recorder.start();
    setRecLabel("Erkennung läuft … gedrückt halten");
    log("Aufnahme gestartet (" + mime + ")");
  } catch(err){
    isRecording = false;
    el.ptt.setAttribute('aria-pressed', 'false');
    log("Mikro abgelehnt/fehlerhaft: " + err.name + " – " + err.message);
  }
}

// ---------- Aufnahme stoppen ----------
async function stopRecord(){
  if (!isRecording) return;
  isRecording = false;
  el.ptt.setAttribute('aria-pressed', 'false');
  try { recorder?.state !== 'inactive' && recorder?.stop(); } catch(e){}
  try { media?.getTracks().forEach(t => t.stop()); } catch(e){}
  setRecLabel("Sende Audio …");
}

async function onStop(){
  const blob = new Blob(chunks, { type: recorder?.mimeType || 'audio/mp4' });
  const kb = Math.round(blob.size/1024);
  chunks = [];
  log(`Audio fertig: ${kb} KB`);
  if (!blob.size) { setRecLabel("Keine Aufnahme – erneut versuchen"); return; }

  // iOS: m4a bevorzugt
  const fname = (recorder?.mimeType || '').includes('mp4') ? 'speech.m4a' : 'speech.webm';

  const fd = new FormData();
  fd.append('audio', blob, fname);

  try {
    const res = await fetch(WEBHOOK, { method:'POST', body: fd });
    log(`Upload Status: ${res.status}`);
    const data = await res.json().catch(()=> ({}));
    const text = (data && (data.output || data.text)) || "";

    if (text) el.said.textContent = el.said.textContent === '–' ? '…' : el.said.textContent;
    el.answer.textContent = text || "–";
    setRecLabel("bereit – tippen & halten zum Sprechen");

    if (data.ttsUrl) {
      // Serverseitiges TTS abspielen
      el.audio.src = data.ttsUrl;
      try { await el.audio.play(); } catch(e){}
    } else if (text) {
      speak(text);
    }
  } catch(err){
    log("Fehler beim Senden: " + err.message);
    setRecLabel("Fehler – erneut versuchen");
  }
}

// ---------- TTS (Browser), iOS-freundlich ----------
function speak(txt){
  try { window.speechSynthesis.cancel(); } catch(e){}
  const u = new SpeechSynthesisUtterance();

  // Bud-Style
  u.rate = 0.82;   // langsamer
  u.pitch = 0.6;   // tiefer
  u.volume = 1.0;

  const getVoice = () => {
    const list = window.speechSynthesis.getVoices();
    return list.find(v => /de|german|deu/i.test(v.lang)) || list[0];
  };
  const trySpeak = () => {
    const v = getVoice();
    if (!v) return false;
    u.voice = v;
    // Satzzeichen entfernen, damit nichts „vorgelesen“ wird
    u.text = (txt||"").replace(/[^\w äöüÄÖÜß]/g, ' ').replace(/\s+/g, ' ').trim();
    window.speechSynthesis.speak(u);
    return true;
  };
  if (!trySpeak()) {
    window.speechSynthesis.onvoiceschanged = () => trySpeak();
  }
}

// ---------- Pointer Events: robust für Touch + Maus ----------
let pressed = false;
el.ptt.addEventListener('pointerdown', async (ev) => {
  pressed = true;
  el.ptt.setPointerCapture?.(ev.pointerId);
  await startRecord();
}, {passive:true});

const end = async (ev) => {
  if (!pressed) return;
  pressed = false;
  await stopRecord();
};
['pointerup','pointercancel','pointerleave'].forEach(t => {
  el.ptt.addEventListener(t, end, {passive:true});
});

// ---------- Sicherheitsnetz: an Tippen Audio/Sprachsystem reaktivieren ----------
['pointerdown','click','touchstart','touchend'].forEach(type=>{
  document.addEventListener(type, ()=> {
    if (!spokenOnce) { primeAudio(); spokenOnce = true; }
    try { if (speechSynthesis.paused) speechSynthesis.resume(); } catch(e){}
  }, {passive:true});
});

</script>
</body>
</html>

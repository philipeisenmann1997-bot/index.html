<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Push-to-Talk (Text only)</title>
  <style>
    :root { --bg:#0b0f14; --muted:#8aa0b2; --accent:#34c759; --danger:#ff453a; }
    * { box-sizing:border-box }
    html, body { height:100% }
    body{
      margin:0; background:#0b0f14; color:#dbe7f3;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      -webkit-tap-highlight-color:transparent; touch-action:manipulation;
    }
    .wrap{ min-height:100dvh; display:flex; align-items:center; justify-content:center; padding:20px }
    .card{
      width:min(880px,94vw); background:#111922; border-radius:18px;
      box-shadow:0 12px 36px rgba(0,0,0,.45); padding:22px;
    }
    h1{ margin:0 0 10px; font-weight:800; letter-spacing:.2px }
    .row{ display:flex; gap:12px; align-items:center; margin:6px 0 12px; flex-wrap:wrap }
    .small{ font-size:.9rem; color:#9bb0c3 }
    #ptt{
      display:block; width:100%;
      padding:18px 22px; border-radius:16px; border:1px solid #1d2a37;
      background:var(--accent); color:#051015; font-size:1.15rem; font-weight:800;
      user-select:none; -webkit-user-select:none; cursor:pointer;
    }
    #ptt[disabled]{ filter:grayscale(.6); opacity:.65; cursor:not-allowed }
    .bubble{ background:#0f1720; border:1px solid #1d2a37; border-radius:14px; padding:12px 14px; margin-top:10px }
    .log{ font-family:ui-monospace,Menlo,Consolas,monospace; font-size:.86rem; color:#a9bcd0; white-space:pre-wrap }
    .inputRow{ display:flex; gap:8px; margin-top:10px }
    .inputRow input{
      flex:1; background:#0f1720; border:1px solid #1d2a37; color:#dbe7f3;
      border-radius:12px; padding:12px 14px; font-size:1rem
    }
    .inputRow button{
      padding:12px 16px; border-radius:12px; border:1px solid #1d2a37; background:#2a845f; color:#eafff6; font-weight:700
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Push-to-Talk</h1>

      <div class="row">
        <span class="small" id="styleLbl">Stil: tief, ruhig</span>
        <span class="small" id="recLbl">bereit – tippen &amp; halten zum Sprechen</span>
      </div>

      <!-- Button triggert NUR Web Speech (wenn verfügbar) -->
      <button id="ptt" type="button">Zum Sprechen tippen &amp; halten</button>

      <!-- Fallback-Textfeld (wenn keine SpeechRecognition vorhanden) -->
      <div id="fallbackBox" class="inputRow" style="display:none">
        <input id="fallbackInput" type="text" placeholder="Text eingeben und senden …" />
        <button id="fallbackSend" type="button">Senden</button>
      </div>

      <div class="bubble">
        <div class="small"><b>Gesagt:</b> <span id="said">–</span></div>
        <div class="small"><b>Antwort:</b> <span id="answer">–</span></div>
      </div>

      <div class="bubble">
        <div class="log" id="log">Bereit.</div>
      </div>

      <audio id="player" playsinline preload="none"></audio>
    </div>
  </div>

<script>
/* ------------------- Konfiguration ------------------- */
const WEBHOOK = "https://n8n.srv1112525.hstgr.cloud/webhook/adbfc875-ecdc-433b-85f9-aba25b8beaa5";

/* ------------------- DOM Refs ------------------------ */
const el = {
  ptt: document.getElementById('ptt'),
  recLbl: document.getElementById('recLbl'),
  said: document.getElementById('said'),
  answer: document.getElementById('answer'),
  log: document.getElementById('log'),
  audio: document.getElementById('player'),
  fallbackBox: document.getElementById('fallbackBox'),
  fallbackInput: document.getElementById('fallbackInput'),
  fallbackSend: document.getElementById('fallbackSend'),
};

function log(t){ el.log.textContent = t; }
function setRecLabel(t){ el.recLbl.textContent = t; }

/* ------------------- Speech Setup -------------------- */
const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;
let isRecording = false;

if (SR) {
  recognition = new SR();
  recognition.lang = "de-DE";
  recognition.interimResults = false;
  recognition.continuous = false;

  recognition.onresult = async (ev) => {
    const text = (ev.results?.[0]?.[0]?.transcript || "").trim();
    if (!text) { log("Nichts erkannt."); setRecLabel("bereit – tippen & halten zum Sprechen"); return; }
    el.said.textContent = text;
    await sendTextToN8n(text);
  };
  recognition.onerror = (ev) => {
    log("Erkennungsfehler: " + ev.error);
    isRecording = false;
    setRecLabel("bereit – tippen & halten zum Sprechen");
  };
  recognition.onend = () => {
    isRecording = false;
    setRecLabel("bereit – tippen & halten zum Sprechen");
  };
} else {
  // Kein SpeechRecognition: Fallback zeigen
  el.fallbackBox.style.display = "flex";
  log("Hinweis: Dieser Browser bietet keine Spracherkennung. Nutze die Texteingabe.");
}

/* ------------------- Nur TEXT an n8n ----------------- */
async function sendTextToN8n(text){
  setRecLabel("sende …");
  log("Sende Text an n8n …");
  try {
    const res = await fetch(WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        text,
        input: { text },     // zweiter Pfad, falls dein Normalize-Input darauf hört
        source: 'voice-web'
      })
    });
    const data = await res.json().catch(()=> ({}));
    const reply = (data.output || data.text || "").toString();
    el.answer.textContent = reply || "–";
    setRecLabel("bereit – tippen & halten zum Sprechen");
    log(`Antwort erhalten (${res.status})`);

    // Optional serverseitiges TTS-File
    if (data.ttsUrl) {
      el.audio.src = data.ttsUrl;
      try { await el.audio.play(); } catch(_) {}
    } else if (reply) {
      speak(reply);
    }
  } catch(err){
    log("Fehler beim Senden: " + err.message);
    setRecLabel("Fehler – erneut versuchen");
  }
}

/* ------------------- TTS im Browser ------------------ */
function speak(txt){
  try { window.speechSynthesis.cancel(); } catch(_){}
  const u = new SpeechSynthesisUtterance();
  u.rate = 0.82; u.pitch = 0.6; u.volume = 1.0; // „Bud“-Style
  const pick = () => {
    const vs = speechSynthesis.getVoices();
    return vs.find(v => /de|german|deu/i.test(v.lang)) || vs[0];
  };
  const clean = (s) => (s||"").replace(/[^\w äöüÄÖÜß]/g," ").replace(/\s+/g," ").trim();
  const trySpeak = () => {
    const v = pick();
    if (!v) return false;
    u.voice = v; u.text = clean(txt);
    speechSynthesis.speak(u); return true;
  };
  if (!trySpeak()) speechSynthesis.onvoiceschanged = () => trySpeak();
}

/* ------------- Button-Logik: nur SR starten ---------- */
el.ptt.addEventListener('pointerdown', () => {
  if (!recognition || isRecording) return;
  isRecording = true;
  setRecLabel("Erkennung läuft … gedrückt halten");
  try { recognition.start(); } catch(_){}
});
['pointerup','pointercancel','pointerleave'].forEach(ev =>
  el.ptt.addEventListener(ev, () => {
    if (!recognition || !isRecording) return;
    try { recognition.stop(); } catch(_){}
  }, {passive:true})
);

/* ----------------- Fallback-Senden ------------------- */
el.fallbackSend.addEventListener('click', async () => {
  const t = el.fallbackInput.value.trim();
  if (!t) return;
  el.said.textContent = t;
  el.fallbackInput.value = "";
  await sendTextToN8n(t);
});
el.fallbackInput.addEventListener('keydown', (e)=>{
  if (e.key === 'Enter') el.fallbackSend.click();
});
</script>
</body>
</html>
